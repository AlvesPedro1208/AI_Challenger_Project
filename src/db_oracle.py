# src/db_oracle.py
import os, json, datetime as dt
import oracledb
from dotenv import load_dotenv; load_dotenv()

# ENV
ORA_HOST = os.getenv("ORA_HOST", "localhost")
ORA_PORT = int(os.getenv("ORA_PORT", "1521"))
ORA_SID  = os.getenv("ORA_SID", "orcl")
ORA_USER = os.getenv("ORA_USER")
ORA_PASS = os.getenv("ORA_PASSWORD")
SCHEMA   = os.getenv("ORA_SCHEMA", ORA_USER or "").upper()  # ex.: RM558897

def _dsn():
    return oracledb.makedsn(ORA_HOST, ORA_PORT, sid=ORA_SID)

def _connect():
    # Configurar timeout e retry
    try:
        # Configurar timeout global para conexões Oracle
        oracledb.defaults.config_dir = None
        
        conn = oracledb.connect(
            user=ORA_USER, 
            password=ORA_PASS, 
            dsn=_dsn()
        )
        
        # Configurar timeout na conexão
        conn.autocommit = False
        return conn
        
    except Exception as e:
        print(f"[ERRO] Falha na conexão Oracle: {e}")
        raise

def _ts(epoch_s: float) -> dt.datetime:
    # timestamp UTC com tzinfo (Oracle TIMESTAMP WITH TIME ZONE)
    return dt.datetime.fromtimestamp(epoch_s, tz=dt.timezone.utc)

def init_db():
    """Cria tabelas/views se não existirem (idempotente). Rode uma vez; ignora erros de 'já existe'."""
    ddl = [
        # TABELA: EVENTOS_LOJA (anteriormente eventos)
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE TABLE {SCHEMA}.eventos_loja (
              id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              data_hora       TIMESTAMP(6) WITH TIME ZONE NOT NULL,
              id_pessoa       VARCHAR2(64)   NOT NULL,
              id_camera       VARCHAR2(32)   NOT NULL,
              tipo_evento     VARCHAR2(30)   NOT NULL,
              id_roi          VARCHAR2(128),
              confianca       NUMBER(5,4),
              dados_extras    CLOB CHECK (dados_extras IS JSON)
            )
          ]';
        EXCEPTION WHEN OTHERS THEN
          IF SQLCODE != -955 THEN RAISE; END IF;  -- ORA-00955: name is already used by an existing object
        END;
        """,
        f"""
        BEGIN
          EXECUTE IMMEDIATE 'ALTER TABLE {SCHEMA}.eventos_loja ADD CONSTRAINT eventos_loja_tipo_chk
            CHECK (tipo_evento IN (''entrar_loja'',''sair_loja'',''olhar_prateleira_baixa'',''segurar_objeto_media'',''colocar_carrinho_alta'',''validacao_caixa'',''permanencia_baixa'',''alcance_medio'',''sair_alta''))';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -2264 THEN RAISE; END IF; END; -- já existe
        """,
        f"""
        BEGIN
          EXECUTE IMMEDIATE 'ALTER TABLE {SCHEMA}.eventos_loja ADD CONSTRAINT eventos_loja_confianca_range
            CHECK (confianca IS NULL OR (confianca >= 0 AND confianca <= 1))';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -2264 THEN RAISE; END IF; END;
        """,
        f"BEGIN EXECUTE IMMEDIATE 'CREATE INDEX {SCHEMA}.idx_eventos_loja_data_hora ON {SCHEMA}.eventos_loja (data_hora)'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;",
        f"BEGIN EXECUTE IMMEDIATE 'CREATE INDEX {SCHEMA}.idx_eventos_loja_pessoa ON {SCHEMA}.eventos_loja (id_pessoa)'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;",
        f"BEGIN EXECUTE IMMEDIATE 'CREATE INDEX {SCHEMA}.idx_eventos_loja_cam_data ON {SCHEMA}.eventos_loja (id_camera, data_hora)'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;",

        # TABELA: CAMINHOS_CLIENTE (anteriormente caminhos)
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE TABLE {SCHEMA}.caminhos_cliente (
              id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              data_hora  TIMESTAMP(6) WITH TIME ZONE NOT NULL,
              id_pessoa  VARCHAR2(64) NOT NULL,
              x          NUMBER(10,2) NOT NULL,
              y          NUMBER(10,2) NOT NULL,
              id_roi     VARCHAR2(128),
              id_camera  VARCHAR2(32) NOT NULL
            )
          ]';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
        """,
        f"BEGIN EXECUTE IMMEDIATE 'CREATE INDEX {SCHEMA}.idx_caminhos_cliente_cam_data ON {SCHEMA}.caminhos_cliente (id_camera, data_hora)'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;",

        # TABELA: SESSOES_CLIENTE (anteriormente sessoes)
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE TABLE {SCHEMA}.sessoes_cliente (
              id_pessoa       VARCHAR2(64) PRIMARY KEY,
              primeira_data   TIMESTAMP(6) WITH TIME ZONE NOT NULL,
              ultima_data     TIMESTAMP(6) WITH TIME ZONE NOT NULL,
              id_camera       VARCHAR2(32) NOT NULL
            )
          ]';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
        """,

        # TABELA: OBJETOS_CLIENTE (mantém o nome)
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE TABLE {SCHEMA}.objetos_cliente (
              id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              data_hora     TIMESTAMP(6) WITH TIME ZONE NOT NULL,
              id_pessoa     VARCHAR2(64) NOT NULL,
              id_camera     VARCHAR2(32) NOT NULL,
              tipo_objeto   VARCHAR2(50),
              id_roi        VARCHAR2(128),
              acao          VARCHAR2(20) CHECK (acao IN ('pegar','segurar','colocar','colocar_carrinho')),
              confianca     NUMBER(5,4)
            )
          ]';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
        """,
        f"BEGIN EXECUTE IMMEDIATE 'CREATE INDEX {SCHEMA}.idx_objetos_cliente_pessoa ON {SCHEMA}.objetos_cliente (id_pessoa, data_hora)'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;",

        # TABELA: VALIDACAO_COMPRA (mantém o nome)
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE TABLE {SCHEMA}.validacao_compra (
              id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              data_hora       TIMESTAMP(6) WITH TIME ZONE NOT NULL,
              id_pessoa       VARCHAR2(64) NOT NULL,
              id_camera       VARCHAR2(32) NOT NULL,
              item_previsto   VARCHAR2(128),
              compra_real     VARCHAR2(128),
              conversao       NUMBER(1) CHECK (conversao IN (0,1)),
              id_roi          VARCHAR2(128)
            )
          ]';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
        """,

        # TABELA: VIDEOS_ANALISADOS (nova tabela para armazenar informações dos vídeos)
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE TABLE {SCHEMA}.videos_analisados (
              id                NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              nome_arquivo      VARCHAR2(255) NOT NULL,
              data_analise      TIMESTAMP(6) WITH TIME ZONE NOT NULL,
              duracao_segundos  NUMBER(10,2) NOT NULL,
              id_camera         VARCHAR2(32) NOT NULL,
              status_analise    VARCHAR2(20) DEFAULT 'concluida' CHECK (status_analise IN ('em_andamento','concluida','erro')),
              total_clientes    NUMBER DEFAULT 0,
              total_eventos     NUMBER DEFAULT 0
            )
          ]';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
        """,
        f"BEGIN EXECUTE IMMEDIATE 'CREATE INDEX {SCHEMA}.idx_videos_analisados_data ON {SCHEMA}.videos_analisados (data_analise)'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;",
        f"BEGIN EXECUTE IMMEDIATE 'CREATE INDEX {SCHEMA}.idx_videos_analisados_arquivo ON {SCHEMA}.videos_analisados (nome_arquivo)'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;",

        # VIEWS EM PORTUGUÊS
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE OR REPLACE VIEW {SCHEMA}.v_funil_por_camera AS
            SELECT
              id_camera,
              SUM(CASE WHEN tipo_evento = 'permanencia_baixa' THEN 1 ELSE 0 END) AS intencao_baixa,
              SUM(CASE WHEN tipo_evento = 'alcance_medio' THEN 1 ELSE 0 END) AS intencao_media,
              SUM(CASE WHEN tipo_evento IN ('sair_alta','colocar_carrinho_alta') THEN 1 ELSE 0 END) AS intencao_alta,
              MIN(data_hora) AS primeira_data,
              MAX(data_hora) AS ultima_data
            FROM {SCHEMA}.eventos_loja
            GROUP BY id_camera
          ]';
        END;
        """,
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE OR REPLACE VIEW {SCHEMA}.v_funil_por_roi AS
            SELECT
              id_camera,
              NVL(id_roi,'(nenhuma)') AS id_roi,
              SUM(CASE WHEN tipo_evento = 'permanencia_baixa' THEN 1 ELSE 0 END) AS intencao_baixa,
              SUM(CASE WHEN tipo_evento = 'alcance_medio' THEN 1 ELSE 0 END) AS intencao_media,
              SUM(CASE WHEN tipo_evento IN ('sair_alta','colocar_carrinho_alta') THEN 1 ELSE 0 END) AS intencao_alta
            FROM {SCHEMA}.eventos_loja
            GROUP BY id_camera, NVL(id_roi,'(nenhuma)')
          ]';
        END;
        """,
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE OR REPLACE VIEW {SCHEMA}.v_eventos_por_minuto AS
            SELECT
              CAST(TRUNC(data_hora,'MI') AS TIMESTAMP) AS minuto,
              id_camera,
              NVL(id_roi,'(nenhuma)') AS id_roi,
              SUM(CASE WHEN tipo_evento = 'permanencia_baixa' THEN 1 ELSE 0 END) AS intencao_baixa,
              SUM(CASE WHEN tipo_evento = 'alcance_medio' THEN 1 ELSE 0 END) AS intencao_media,
              SUM(CASE WHEN tipo_evento IN ('sair_alta','colocar_carrinho_alta') THEN 1 ELSE 0 END) AS intencao_alta
            FROM {SCHEMA}.eventos_loja
            GROUP BY TRUNC(data_hora,'MI'), id_camera, NVL(id_roi,'(nenhuma)')
          ]';
        END;
        """,
        f"""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE OR REPLACE VIEW {SCHEMA}.v_mapa_calor_20px AS
            SELECT
              id_camera,
              NVL(id_roi,'(nenhuma)') AS id_roi,
              FLOOR(x/20) AS bin_x,
              FLOOR(y/20) AS bin_y,
              COUNT(*) AS quantidade
            FROM {SCHEMA}.caminhos_cliente
            GROUP BY id_camera, NVL(id_roi,'(nenhuma)'), FLOOR(x/20), FLOOR(y/20)
          ]';
        END;
        """,
    ]
    with _connect() as conn:
        with conn.cursor() as cur:
            for block in ddl:
                cur.execute(block)
        conn.commit()

def log_event(ts, person_id, camera_id, event_type, roi_id=None, conf=None, extra=None):
    payload = json.dumps(extra) if extra else None
    with _connect() as conn, conn.cursor() as cur:
        cur.execute(
            f"""INSERT INTO {SCHEMA}.eventos_loja
                (data_hora, id_pessoa, id_camera, tipo_evento, id_roi, confianca, dados_extras)
                VALUES (:ts, :pid, :cam, :etype, :roi, :conf, :j)""",
            dict(ts=_ts(ts), pid=person_id, cam=camera_id,
                 etype=event_type, roi=roi_id, conf=conf, j=payload)
        )
        conn.commit()

def log_path(ts, person_id, x, y, roi_id=None, camera_id=None):
    with _connect() as conn, conn.cursor() as cur:
        cur.execute(
            f"""INSERT INTO {SCHEMA}.caminhos_cliente
                (data_hora, id_pessoa, x, y, id_roi, id_camera)
                VALUES (:ts, :pid, :x, :y, :roi, :cam)""",
            dict(ts=_ts(ts), pid=person_id, x=float(x), y=float(y), roi=roi_id, cam=camera_id)
        )
        conn.commit()

def upsert_session(ts, person_id, camera_id):
    with _connect() as conn, conn.cursor() as cur:
        cur.execute(
            f"""
            MERGE INTO {SCHEMA}.sessoes_cliente s
            USING (SELECT :pid id_pessoa, :ts data_hora, :cam id_camera FROM dual) v
              ON (s.id_pessoa = v.id_pessoa)
            WHEN MATCHED THEN UPDATE SET s.ultima_data = v.data_hora, s.id_camera = v.id_camera
            WHEN NOT MATCHED THEN INSERT (id_pessoa, primeira_data, ultima_data, id_camera)
                 VALUES (v.id_pessoa, v.data_hora, v.data_hora, v.id_camera)
            """,
            dict(pid=person_id, ts=_ts(ts), cam=camera_id)
        )
        conn.commit()

def log_customer_object(ts, person_id, camera_id, object_type=None, roi_id=None, action=None, confidence=None):
    """Registra ações com objetos (pegar, segurar, colocar no carrinho)"""
    with _connect() as conn, conn.cursor() as cur:
        cur.execute(
            f"""INSERT INTO {SCHEMA}.objetos_cliente
                (data_hora, id_pessoa, id_camera, tipo_objeto, id_roi, acao, confianca)
                VALUES (:ts, :pid, :cam, :obj_type, :roi, :action, :conf)""",
            dict(ts=_ts(ts), pid=person_id, cam=camera_id, 
                 obj_type=object_type, roi=roi_id, action=action, conf=confidence)
        )
        conn.commit()

def log_purchase_validation(ts, person_id, camera_id, predicted_item=None, actual_purchase=None, conversion=None, roi_id=None):
    """Registra validação de compra no caixa"""
    with _connect() as conn, conn.cursor() as cur:
        cur.execute(
            f"""INSERT INTO {SCHEMA}.validacao_compra
                (data_hora, id_pessoa, id_camera, item_previsto, compra_real, conversao, id_roi)
                VALUES (:ts, :pid, :cam, :pred, :actual, :conv, :roi)""",
            dict(ts=_ts(ts), pid=person_id, cam=camera_id,
                 pred=predicted_item, actual=actual_purchase, conv=conversion, roi=roi_id)
        )
        conn.commit()

def log_video_analysis(nome_arquivo, duracao_segundos, camera_id, total_clientes=0, total_eventos=0):
    """Registra um vídeo analisado com sua duração"""
    with _connect() as conn, conn.cursor() as cur:
        cur.execute(
            f"""INSERT INTO {SCHEMA}.videos_analisados
                (nome_arquivo, data_analise, duracao_segundos, id_camera, total_clientes, total_eventos)
                VALUES (:nome, :data, :duracao, :cam, :clientes, :eventos)""",
            dict(nome=nome_arquivo, data=_ts(dt.datetime.now().timestamp()), duracao=float(duracao_segundos),
                 cam=camera_id, clientes=total_clientes, eventos=total_eventos)
        )
        conn.commit()

def get_total_video_duration():
    """Retorna a soma total da duração de todos os vídeos analisados em segundos"""
    with _connect() as conn, conn.cursor() as cur:
        cur.execute(f"SELECT COALESCE(SUM(duracao_segundos), 0) FROM {SCHEMA}.videos_analisados WHERE status_analise = 'concluida'")
        result = cur.fetchone()
        return result[0] if result else 0

def save_analysis_data_batch(events_data, objects_data, paths_data, sessions_data):
    """
    Salva dados de análise em lote para melhor performance e evitar timeouts
    """
    try:
        with _connect() as conn:
            with conn.cursor() as cur:
                # Salvar eventos em lote usando executemany (mais eficiente)
                if events_data:
                    print(f"[INFO] Salvando {len(events_data)} eventos em lote...")
                    cur.executemany(
                        f"""INSERT INTO {SCHEMA}.eventos_loja 
                            (data_hora, id_pessoa, id_camera, tipo_evento, id_roi, confianca, dados_extras)
                            VALUES (:ts, :pid, :cam, :evt, :roi, :conf, :extra)""",
                        events_data
                    )
                
                # Salvar objetos em lote usando executemany
                if objects_data:
                    print(f"[INFO] Salvando {len(objects_data)} objetos em lote...")
                    cur.executemany(
                        f"""INSERT INTO {SCHEMA}.objetos_cliente 
                            (data_hora, id_pessoa, id_camera, tipo_objeto, id_roi, acao, confianca)
                            VALUES (:ts, :pid, :cam, :obj_type, :roi, :action, :conf)""",
                        objects_data
                    )
                
                # Salvar paths em lote usando executemany
                if paths_data:
                    print(f"[INFO] Salvando {len(paths_data)} posições em lote...")
                    cur.executemany(
                        f"""INSERT INTO {SCHEMA}.caminhos_cliente 
                            (data_hora, id_pessoa, id_camera, x, y, id_roi)
                            VALUES (:ts, :pid, :cam, :x, :y, :roi)""",
                        paths_data
                    )
                
                # Salvar sessões em lote (usando INSERT simples para evitar complexidade do MERGE)
                if sessions_data:
                    print(f"[INFO] Salvando {len(sessions_data)} sessões em lote...")
                    for session in sessions_data:
                        try:
                            cur.execute(
                                f"""INSERT INTO {SCHEMA}.sessoes_cliente (id_pessoa, primeira_data, ultima_data, id_camera)
                                    VALUES (:pid, :ts, :ts, :cam)""",
                                session
                            )
                        except Exception:
                            # Se já existe, atualiza a última data
                            cur.execute(
                                f"""UPDATE {SCHEMA}.sessoes_cliente 
                                    SET ultima_data = :ts 
                                    WHERE id_pessoa = :pid AND id_camera = :cam""",
                                session
                            )
                
                # Commit uma única vez para todas as operações
                conn.commit()
                print("[OK] Todos os dados salvos com sucesso em lote!")
                
    except Exception as e:
        print(f"[ERRO] Falha ao salvar dados em lote: {e}")
        # Não fazer raise para não interromper o fluxo
        print("[INFO] Continuando sem salvar no banco...")
